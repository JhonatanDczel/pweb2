\section{Introducción}

En este informe, se detalla el desarrollo de un juego de Ahorcado utilizando Angular. El proyecto fue realizado como parte de un laboratorio educativo, con el objetivo de poner en práctica habilidades en el desarrollo de aplicaciones web interactivas. Angular, un framework de JavaScript de desarrollo de aplicaciones web de una sola página (SPA), fue utilizado debido a su robustez y facilidad para gestionar componentes y estados.

\section{Estructura del Proyecto}

El proyecto consta de varios componentes que trabajan en conjunto para crear la experiencia de juego del Ahorcado. A continuación, se describe cada componente en detalle:

\begin{enumerate}
  \item \textbf{Componente Hangman}
  \item \textbf{Componente HangmanDisplay}
  \item \textbf{Componente HangmanKeyboard}
  \item \textbf{Componente HangmanQuestion}
\end{enumerate}

Cada uno de estos componentes tiene su propio propósito y funcionalidad, y están diseñados para interactuar entre sí.

\section{Componente Hangman}

\subsection{hangman.component.html}

El archivo HTML de este componente define la estructura visual del juego. Utiliza varios subcomponentes y directivas de Angular para gestionar el flujo del juego.

\begin{lstlisting}[language=HTML]
<div class="hangman">
  <app-hangman-display (gameFinished)="onGameFinished()" [guesses]="guesses" [question]="question"></app-hangman-display>
  <ng-container *ngIf="!restartGameBtnShown else restartGameBtn">
    <app-hangman-question [guesses]="guesses" [question]="question"></app-hangman-question>
    <app-hangman-keyboard (keyPressed)="guess($event)" [question]="question"></app-hangman-keyboard>
  </ng-container>
</div>
<ng-template #restartGameBtn>
  <button class="btn" (click)="reset()">
    {{'>>Restart Game<<'}}
  </button>
</ng-template>
\end{lstlisting}

\subsection{hangman.component.scss}

El archivo SCSS define el estilo del componente, asegurando que el diseño sea flexible y esté centrado en la pantalla.

\begin{lstlisting}[language=CSS]
.hangman {
  display: flex;
  max-width: 960px;
  flex-direction: column;
  align-items: center;
}
\end{lstlisting}

\subsection{hangman.component.ts}

Este archivo contiene la lógica del juego. Gestiona el estado del juego, maneja las entradas del usuario y coordina la interacción entre los subcomponentes.

\begin{lstlisting}[language=TypeScript]
import { Location } from '@angular/common';
import { Component, OnInit } from '@angular/core';
import { HangmanService } from 'src/app/services/hangman.service';

@Component({
  selector: 'app-hangman',
  templateUrl: './hangman.component.html',
  styleUrls: ['./hangman.component.scss'],
})
export class HangmanComponent implements OnInit {
  question: string = '';
  questions: string[] = [];
  guesses: string[] = [];
  category: string = '';
  restartGameBtnShown = false;

  constructor(
    private hangmanService: HangmanService,
    private location: Location
  ) {}

  ngOnInit(): void {
    let jsonPath;
    const url = this.location.path();
    if (url.includes('jsonPath')) {
      jsonPath = url.split('jsonPath=')[1];
    }
    this.hangmanService.getQuestions(jsonPath).subscribe((response) => {
      this.questions = response.items;
      this.category = response.category;
      this.pickNewQuestion();
    });
  }

  guess(letter: string) {
    if (!letter || this.guesses.includes(letter)) {
      return;
    }
    this.guesses = [...this.guesses, letter];
  }

  dummyClick() {
    const key = prompt('Enter a key') || '';
    this.guess(key);
  }

  reset() {
    this.guesses = [];
    this.pickNewQuestion();
    this.restartGameBtnShown = false;
  }

  pickNewQuestion() {
    const randomIndex = Math.floor(Math.random() * this.questions.length);
    this.question = this.questions[randomIndex];
    console.log(this.question);
  }

  onGameFinished() {
    this.restartGameBtnShown = true;
  }
}
\end{lstlisting}

\subsection{hangman.component.spec.ts}

Este archivo contiene pruebas unitarias para asegurar que el componente funcione correctamente.

\begin{lstlisting}[language=TypeScript]
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { HangmanComponent } from './hangman.component';

describe('HangmanComponent', () => {
  let component: HangmanComponent;
  let fixture: ComponentFixture<HangmanComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ HangmanComponent ]
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(HangmanComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
\end{lstlisting}

\section{Componente HangmanDisplay}

\subsection{hangman-display.component.html}

El archivo HTML de este componente contiene el SVG que representa el dibujo del Ahorcado. Utiliza las propiedades de entrada para actualizar el estado del dibujo según los errores del jugador.

\begin{lstlisting}[language=HTML]
<svg
  version="1.1"
  id="hangman"
  xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  x="0px"
  y="0px"
  width="250px"
  height="350px"
  viewBox="0 0 250 350"
  enable-background="new 0 0 250 350"
  xml:space="preserve"
>
  <line
    id="base1"
    fill="none"
    stroke="#000000"
    stroke-width="10"
    stroke-miterlimit="10"
    x1="28"
    y1="326.034"
    x2="219"
    y2="326.034"
  />
  <!-- Más líneas y figuras aquí -->
</svg>
\end{lstlisting}

\subsection{hangman-display.component.scss}

El archivo SCSS define estilos adicionales para el componente, incluyendo animaciones para el dibujo del Ahorcado.

\begin{lstlisting}[language=CSS]
.mistakes-count {
  text-align: center;
}

.man-bounce {
  animation: shimmy 1s infinite;
  animation-direction: alternate;
}

@keyframes shimmy {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(0px, 17px);
  }
}
\end{lstlisting}

\subsection{hangman-display.component.ts}

Este archivo contiene la lógica que determina el estado del dibujo del Ahorcado según las conjeturas del jugador.

\begin{lstlisting}[language=TypeScript]
import { Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-hangman-display',
  templateUrl: './hangman-display.component.html',
  styleUrls: ['./hangman-display.component.scss'],
})
export class HangmanDisplayComponent implements OnInit, OnChanges {
  @Input() guesses: string[] = [];
  @Input() question: string = '';
  @Output() gameFinished = new EventEmitter<boolean>();
  MAX_MISTAKES = 7;
  mistakesRemaining: number;
  success: boolean = false;

  constructor() {
    this.mistakesRemaining = this.MAX_MISTAKES;
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (
      changes?.['question']?.currentValue &&
      changes?.['question'].currentValue !== changes?.['question'].previousValue
    ) {
      this.mistakesRemaining = this.MAX_MISTAKES;
      this.success = false;
    }
    const guessesCurrentValue = changes?.['guesses']?.currentValue;
    if (
      guessesCurrentValue &&
      guessesCurrentValue.length &&
      guessesCurrentValue !== changes['guesses'].previousValue
    ) {
      const char = [...guessesCurrentValue].pop();
      this.checkGuess(char);
    }
  }

  checkGuess(letter: string) {
    let didWin = true;
    this.mistakesRemaining -= this.wasGuessAMistake(letter);
    for (let i = 0; i < this.question.length; i++) {
        didWin = false;
        break;
      }
    }
    this.success = didWin;
    if (this.success || this.mistakesRemaining === 0) {
      this.gameFinished.emit(this.success);
    }
  }

  wasGuessAMistake(letter: string) {
    for (let i = 0; i < this.question.length; i++) {
      if (this.question[i].toLowerCase() === letter.toLowerCase()) {
        return 0;
      }
    }
    return 1;
  }

  ngOnInit(): void {}
\end{lstlisting}

\subsection{hangman-display.component.spec.ts}

Este archivo contiene pruebas unitarias para verificar el correcto funcionamiento del componente.

\begin{lstlisting}[language=TypeScript]
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { HangmanDisplayComponent } from './hangman-display.component';

describe('HangmanDisplayComponent', () => {
  let component: HangmanDisplayComponent;
  let fixture: ComponentFixture<HangmanDisplayComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ HangmanDisplayComponent ]
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(HangmanDisplayComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
\end{lstlisting}

\section{Componente HangmanQuestion}

\subsection{hangman-question.component.html}

Este archivo HTML muestra las letras de la palabra o frase que el jugador debe adivinar, ocultando las letras que aún no han sido adivinadas.

\begin{lstlisting}[language=HTML]
<div class="question">
  <div class="question-letter" *ngFor="let letter of question">
    <span>{{ guesses.includes(letter.toLowerCase()) ? letter : '_' }}</span>
  </div>
</div>
\end{lstlisting}

\subsection{hangman-question.component.scss}

Este archivo SCSS define estilos para el componente de la pregunta, incluyendo la apariencia de las letras y los guiones.

\begin{lstlisting}[language=CSS]
.question {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin-bottom: 20px;
}

.question-letter {
  font-size: 2em;
  margin: 0 5px;
}
\end{lstlisting}

\subsection{hangman-question.component.ts}

Este archivo contiene la lógica del componente, que maneja la actualización de las letras mostradas según las conjeturas del jugador.

\begin{lstlisting}[language=TypeScript]
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-hangman-question',
  templateUrl: './hangman-question.component.html',
  styleUrls: ['./hangman-question.component.scss'],
})
export class HangmanQuestionComponent implements OnChanges {
  @Input() guesses: string[] = [];
  @Input() question: string = '';

  ngOnChanges(changes: SimpleChanges): void {
    // Este método se llama cuando las propiedades de entrada cambian
  }
}
\end{lstlisting}

\subsection{hangman-question.component.spec.ts}

Este archivo contiene pruebas unitarias para verificar el correcto funcionamiento del componente.

\begin{lstlisting}[language=TypeScript]
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { HangmanQuestionComponent } from './hangman-question.component';

describe('HangmanQuestionComponent', () => {
  let component: HangmanQuestionComponent;
  let fixture: ComponentFixture<HangmanQuestionComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ HangmanQuestionComponent ]
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(HangmanQuestionComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
\end{lstlisting}

\section{Componente HangmanKeyboard}

\subsection{hangman-keyboard.component.html}

Este archivo HTML muestra el teclado virtual que el jugador usa para adivinar las letras. Cada botón representa una letra y está deshabilitado si ya ha sido adivinada.

\begin{lstlisting}[language=HTML]
<div class="keyboard">
  <button
    *ngFor="let key of keys"
    [disabled]="guesses.includes(key)"
    (click)="keyPressed(key)"
    class="key"
  >
    {{ key }}
  </button>
</div>
\end{lstlisting}

\subsection{hangman-keyboard.component.scss}

Este archivo SCSS define estilos para el teclado virtual, asegurando que los botones sean claros y accesibles.

\begin{lstlisting}[language=CSS]
.keyboard {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 300px;
  margin: 20px 0;
}

.key {
  font-size: 1.5em;
  margin: 5px;
  padding: 10px;
  background-color: #ccc;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.key:disabled {
  background-color: #aaa;
  cursor: not-allowed;
}
\end{lstlisting}

\subsection{hangman-keyboard.component.ts}

Este archivo contiene la lógica del componente, que maneja las entradas del teclado virtual y las envía al componente principal para procesarlas.

\begin{lstlisting}[language=TypeScript]
import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';

@Component({
  selector: 'app-hangman-keyboard',
  templateUrl: './hangman-keyboard.component.html',
  styleUrls: ['./hangman-keyboard.component.scss'],
})
export class HangmanKeyboardComponent implements OnInit {
  @Input() guesses: string[] = [];
  @Output() keyPressed = new EventEmitter<string>();

  keys: string[] = 'abcdefghijklmnopqrstuvwxyz'.split('');

  constructor() {}

  ngOnInit(): void {}

  onKeyPressed(key: string) {
    this.keyPressed.emit(key);
  }
}
\end{lstlisting}

\subsection{hangman-keyboard.component.spec.ts}

Este archivo contiene pruebas unitarias para verificar el correcto funcionamiento del componente.

\begin{lstlisting}[language=TypeScript]
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { HangmanKeyboardComponent } from './hangman-keyboard.component';

describe('HangmanKeyboardComponent', () => {
  let component: HangmanKeyboardComponent;
  let fixture: ComponentFixture<HangmanKeyboardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ HangmanKeyboardComponent ]
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(HangmanKeyboardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
\end{lstlisting}

\section{Conclusión}

El desarrollo de este proyecto permitió aplicar y reforzar conocimientos en Angular, incluyendo el manejo de componentes, servicios, y la comunicación entre componentes a través de \texttt{@Input} y \texttt{@Output}. El juego de Ahorcado resultante es una aplicación interactiva y educativa que demuestra cómo Angular puede ser utilizado para crear aplicaciones web complejas y bien estructuradas.

El informe detalla cada aspecto del proyecto, desde la estructura del código hasta los estilos y pruebas unitarias, proporcionando una guía comprensiva sobre cómo desarrollar un proyecto similar.

La experiencia adquirida a lo largo de este proyecto será valiosa para futuros desarrollos en Angular y otros frameworks de desarrollo de aplicaciones web.